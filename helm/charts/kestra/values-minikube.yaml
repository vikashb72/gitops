schema:
  env: minikube

kestra:
  ### This creates a config map of the Kestra configuration
  #configuration: {}
  # Example: Setting the plugin defaults for the Docker runner
  #   kestra:
  #     plugins:
  #       configurations:
  #         - type:  io.kestra.plugin.scripts.runner.docker.Docker
  #           values:
  #             volume-enabled: true
  configuration:
    #datasources:
    #  postgres:
    #    url: jdbc:postgresql://postgres:5432/kestra
    #    driverClassName: org.postgresql.Driver
    #    username: kestra   # DATASOURCES_POSTGRES_USERNAME=kestra
    #    password: k3str4
    kestra:
      #storage:
      #  s3:
      #    accesKey:  environment variable: KESTRA_STORAGE_S3_ACCESS-KEY=myKey
      server:
        basicAuth:
          enabled: false
          #username: kestra-admin@minikube.where-ever.net
      anonymous-usage-report:
        enabled: false
      #elasticsearch:
      #  client:
      #    httpHosts:
      #      - "http://node-1:9200"
      #      - "http://node-2:9200"
      #      - "http://node-3:9200"
      #    loggers:
      #      - level: INFO # mandatory: ERROR, WARN, INFO, DEBUG, TRACE, 
      #        type: PRODUCER # optional: CONSUMER or PRODUCER
      #  basicAuth:
      #    username: "<your-user>"
      #    password: "<your-password>"
      #kafka:
      #  client:
      #    properties:
      #      bootstrap.servers: "host:port"
      #      security.protocol: "SSL"
      #      ssl.endpoint.identification.algorithm: ""
      #      ssl.key.password: "<your-password>"
      #      ssl.keystore.location: "/etc/ssl/private/keystore.p12"
      #      ssl.keystore.password: "<your-password>"
      #      ssl.keystore.type: "PKCS12"
      #      ssl.truststore.location: "/etc/ssl/private/truststore.jks"
      #      ssl.truststore.password: "<your-password>"
      #  defaults:
      #    consumer:
      #      properties:
      #        isolation.level: "read_committed"
      #        auto.offset.reset: "earliest"
      #        enable.auto.commit: "false"
      #    producer:
      #      properties:
      #        acks: "all"
      #        compression.type: "lz4"
      #        max.request.size: "10485760"
      #    stream:
      #      properties:
      #        processing.guarantee: "exactly_once"
      #        replication.factor: "${kestra.kafka.defaults.topic.replicationFactor}"
      #        acks: "all"
      #        compression.type: "lz4"
      #        max.request.size: "10485760"
      #        state.dir: "/tmp/kafka-streams"
      #repository:
      #  type: elasticsearch
    #micronaut:
    #  security:
    #    x509:
    #      enabled: true
    #  ssl:
    #    enabled: true
    #  server:
    #    ssl:
    #      clientAuthentication: need
    #      keyStore:
    #        path: classpath:ssl/keystore.p12
    #        password: ${KEYSTORE_PASSWORD}
    #        type: PKCS12
    #      trustStore:
    #        path: classpath:ssl/truststore.jks
    #        password: ${TRUSTSTORE_PASSWORD}
    #        type: JKS
    # TODO: https://kestra.io/docs/configuration

  ### This will create a Kubernetes Secret for the values provided
  ## This will be appended to kestra-secret with the key application-secrets.yml
  secrets: {}
  # Example: Store your postgres backend credentials in a secret
  #   secrets:
  #     kestra:
  #       datasources:
  #         postgres:
  #           username: pguser
  #           password: mypass123
  #           url: jdbc:postgresql://pghost:5432/db
  
  ### Load Kestra configuration from existing secret
  ## Here this assumes the secret is already deployed and the following apply:
  ## 1. The secret type is "Opaque"
  ## 2. The secret has a single key
  ## 3. The value of the secret is the Kestra configuration.
  externalSecret: {}
    #secretName: secret-name
    #key: application-kestra.yml
  
  ### configuration files
  ## This option allows you to reference existing local files to configure Kestra, e.g.
  configurationPath:
  # configurationPath: /app/application.yml,/app/application-secrets.yml
  
  ### Kestra executable
  executable: /app/kestra
  
  ### Deployments
  deployments:
    webserver:
      enabled: true
      replicaCount: 1
      autoscaler:
        enabled: false
        minReplicas: 1
        maxReplicas: 3
  
    executor:
      enabled: true
  
    indexer:
      enabled: true
  
    scheduler:
      enabled: true
      kind: Deployment
  
    worker:
      enabled: true
  
    standalone:
      enabled: false
  
  # EE only - Define additional group of workers.
  workerGroup:
    workergroupname: # name of the worker group
      enabled: false
  
  # EE only - the Kestra Kubernetes Operator
  operator:
    enabled: false
    image: registry.kestra.io/docker/kestra-operator
    apiKey: ""
    basicAuth: ""
  
  dind:
    enabled: true
    #securityContext:
    #  runAsUser: 0
    #  runAsGroup: 0
  
  #securityContext:
  #  runAsUser: 0
  #  runAsGroup: 0

  ### Kafka
  kafka:
    enabled: true
    global:
      defaultStorageClass: "nfs-client"
      storageClass: "nfs-client"
    listeners:
      client:
        protocol: PLAINTEXT # SASL_SSL
        #sslClientAuth: required
      controller:
        protocol: PLAINTEXT # SASL_SSL
        #sslClientAuth: required
      interbroker:
        protocol: PLAINTEXT # SASL_SSL
        #sslClientAuth: required
      external:
        protocol: PLAINTEXT # SASL_SSL
        #sslClientAuth: required
      #sasl:
      #  interBrokerMechanism: 
      extraVolumes: []
      extraVolumeMounts: []
  
    controller:
      extraVolumes: []
      extraVolumeMounts: []
    broker:
      extraVolumes: []
      extraVolumeMounts: []
    externalAccess:
      enabled: false
    provisioning:
      topics: []
      auth:
        tls:
          type: pem
      extraVolumes: []
      extraVolumeMounts: []

  ### ElasticSearch
  elasticsearch:
    enabled: true
    secret:
      enabled: false  # own es-elastic-credential Secret
    clusterName: "es-kestra"
    createCert: false
    protocol: http
    esConfig:
      elasticsearch.yml: |
        xpack.security.enabled: false
    extraEnvs: []
    #  - name: MY_ENVIRONMENT_VAR
    #    value: the_value_goes_here
    envFrom: []
    # - secretRef:
    #     name: env-secret
    # - configMapRef:
    #     name: config-map
    secretMounts: []
    #  - name: elastic-certificates
    #    secretName: elastic-certificates
    #    path: /usr/share/elasticsearch/config/certs
    #    defaultMode: 0755
    extraVolumes:
      - name: own-ca-bundle
        configMap:
          name: own-ca-bundle
          defaultMode: 0644
          optional: false
          items:
            - key: own-ca-bundle.pem
              path: ca-certificates.crt
    extraVolumeMounts:
      - mountPath: /etc/ssl/certs/
        name: own-ca-bundle
        readOnly: true
    fullnameOverride: "es-kestra"
  
  ### Minio
  minio:
    global:
      defaultStorageClass: "nfs-client"
      storageClass: "nfs-client"
    enabled: true
    auth:
      #rootUser: minio-admin
      #rootPassword: its-not-a-secret
      existingSecret: "minio-credentials"
      rootUserSecretKey: "user"
      rootPasswordSecretKey: "password"
    tls:
      enabled: false
      autoGenerated: false
      existingSecret: ""
    defaultBuckets: kestra
    provisioning:
      enabled: false
      extraVolumes: []
      extraVolumeMounts: []
      buckets: []
      config: []
    automountServiceAccountToken: false
    extraVolumes: []
    extraVolumeMounts: []
    persistence:
      enabled: true
      storageClass: "nfs-client"
    resources:
      requests:
        memory: 512Mi
  
  ### Postgresql
  postgresql:
    enabled: true
    global:
      defaultStorageClass: "nfs-client"
      storageClass: "nfs-client"
      postgresql:
        auth:
          postgresPassword: ""
          username: "kestra"
          password: ""
          database: "kestra"
          existingSecret: "psql-credentials"
          secretKeys:
            adminPasswordKey: "psql-password"
            userPasswordKey: "user-password"
            replicationPasswordKey: "repl-password"
    auth:
      database: kestra
      username: kestra
      #password: kestra
      existingSecret: "psql-credentials"
      secretKeys:
        adminPasswordKey: "psql-password"
        userPasswordKey: "user-password"
        replicationPasswordKey: "repl-password"
    tls:
      enabled: false
      autoGenerated: false
      ##
      certificatesSecret: ""
      certFilename: ""
      certKeyFilename: ""
      certCAFilename: ""
      crlFilename: ""
  
    primary:
      persistence:
        enabled: true
        size: 8Gi
      extraVolumeMounts: []
      extraVolumes: []
  
  ### Service
  service:
    type: ClusterIP
    loadBalancerIP: ""
    management:
      enabled: false
  
  
  ### Ingress
  ingress:
    enabled: false
  
  extraVolumeMounts: []
  
  extraVolumes: []
  
  extraEnv: []
  
  # https://kestra.io/docs/configuration#environment-variables-prefix
  extraConfigMapEnvFrom:
    # - name: my-existing-configmap-no-prefix
    # - name: my-existing-configmap-with-prefix
    #   prefix: KESTRA_
  
  extraSecretEnvFrom:
    - name: kestra-secrets
    # - name: my-existing-no-prefix
    # - name: my-existing-with-prefix
    #   prefix: SECRET_
  
  ### Application Secrets
  ## To pass in secrets of your applications, services etc to Kestra please see the following:
  ## https://kestra.io/docs/how-to-guides/kubernetes-secrets
  
  ### Extra Kubernetes Manifests
  extraManifests: []
    # - apiVersion: v1
    #   kind: Secret
    #   metadata:
    #     name: demo
    #   data:
    #     key: pass123
