consul:
  global:
    enabled: true
  
    logLevel: "info"
  
    logJSON: false
  
    secretsBackend:
      vault:
        vaultNamespace: "vault-system"
  
        # Enabling the Vault secrets backend will replace Kubernetes secrets with referenced Vault secrets.
        enabled: false
  
        # The Vault role for the Consul server.
        # The role must be connected to the Consul server's service account.
        # The role must also have a policy with read capabilities for the following secrets:
        # - gossip encryption key defined by the `global.gossipEncryption.secretName` value
        # - certificate issue path defined by the `server.serverCert.secretName` value
        # - CA certificate defined by the `global.tls.caCert.secretName` value
        # - replication token defined by the `global.acls.replicationToken.secretName` value if `global.federation.enabled` is `true`
        # To discover the service account name of the Consul server, run
        # ```shell-session
        # $ helm template --show-only templates/server-serviceaccount.yaml <release-name> hashicorp/consul
        # ```
        # and check the name of `metadata.name`.
        consulServerRole: ""
  
        # The Vault role for the Consul client.
        # The role must be connected to the Consul client's service account.
        # The role must also have a policy with read capabilities for the gossip encryption
        # key defined by the `global.gossipEncryption.secretName` value.
        # To discover the service account name of the Consul client, run
        # ```shell-session
        # $ helm template --show-only templates/client-serviceaccount.yaml <release-name> hashicorp/consul
        # ```
        # and check the name of `metadata.name`.
        consulClientRole: ""
  
        # A Vault role for the Consul `server-acl-init` job, which manages setting ACLs so that clients and components can obtain ACL tokens.
        # The role must be connected to the `server-acl-init` job's service account.
        # The role must also have a policy with read and write capabilities for the bootstrap, replication or partition tokens
        # To discover the service account name of the `server-acl-init` job, run
        # ```shell-session
        # $ helm template --show-only templates/server-acl-init-serviceaccount.yaml \
        #   --set global.acls.manageSystemACLs=true <release-name> hashicorp/consul
        # ```
        # and check the name of `metadata.name`.
        manageSystemACLsRole: ""
  
        # The Vault role to read Consul connect-injector webhook's CA
        # and issue a certificate and private key.
        # A Vault policy must be created which grants issue capabilities to
        # `global.secretsBackend.vault.connectInject.tlsCert.secretName`.
        connectInjectRole: ""
  
        # The Vault role for all Consul components to read the Consul's server's CA Certificate (unauthenticated).
        # The role should be connected to the service accounts of all Consul components, or alternatively `*` since it
        # will be used only against the `pki/cert/ca` endpoint which is unauthenticated. A policy must be created which grants
        # read capabilities to `global.tls.caCert.secretName`, which is usually `pki/cert/ca`.
        consulCARole: ""
  
        # Configuration for Vault server CA certificate. This certificate will be mounted
        # to any pod where Vault agent needs to run.
        ca:
          # The name of the Kubernetes or Vault secret that holds the Vault CA certificate.
          # A Kubernetes secret must be in the same namespace that Consul is installed into.
          secretName: ""
          # The key within the Kubernetes or Vault secret that holds the Vault CA certificate.
          secretKey: ""
  
        # Configuration for the Vault Connect CA provider.
        # The provider will be configured to use the Vault Kubernetes auth method
        # and therefore requires the role provided by `global.secretsBackend.vault.consulServerRole`
        # to have permissions to the root and intermediate PKI paths.
        # Please refer to [Vault ACL policies](https://developer.hashicorp.com/consul/docs/connect/ca/vault#vault-acl-policies)
        # documentation for information on how to configure the Vault policies.
        connectCA:
          # The address of the Vault server.
          address: ""
  
          # The mount path of the Kubernetes auth method in Vault.
          authMethodPath: "kubernetes"
  
          # The path to a PKI secrets engine for the root certificate.
          # For more details, please refer to [Vault Connect CA configuration](https://developer.hashicorp.com/consul/docs/connect/ca/vault#rootpkipath).
          rootPKIPath: ""
  
          # The path to a PKI secrets engine for the generated intermediate certificate.
          # For more details, please refer to [Vault Connect CA configuration](https://developer.hashicorp.com/consul/docs/connect/ca/vault#intermediatepkipath).
          intermediatePKIPath: ""
  
        connectInject:
          # Configuration to the Vault Secret that Kubernetes uses on
          # Kubernetes pod creation, deletion, and update, to get CA certificates
          # used issued from vault to send webhooks to the ConnectInject.
          caCert:
            # The Vault secret path that contains the CA certificate for
            # Connect Inject webhooks.
            # @type: string
            secretName: null
  
          # Configuration to the Vault Secret that Kubernetes uses on
          # Kubernetes pod creation, deletion, and update, to get TLS certificates
          # used issued from vault to send webhooks to the ConnectInject.
          tlsCert:
            # The Vault secret path that issues TLS certificates for connect
            # inject webhooks.
            # @type: string
            secretName: null
  
    gossipEncryption:
      # Automatically generate a gossip encryption key and save it to a Kubernetes or Vault secret.
      autoGenerate: false
      # The name of the Kubernetes secret or Vault secret path that holds the gossip
      # encryption key. A Kubernetes secret must be in the same namespace that Consul is installed into.
      secretName: ""
      # The key within the Kubernetes secret or Vault secret key that holds the gossip
      # encryption key.
      secretKey: ""
      # Override global log verbosity level for gossip-encryption-autogenerate-job pods. One of "trace", "debug", "info", "warn", or "error".
      # @type: string
      logLevel: ""
  
    # Enables [TLS](https://developer.hashicorp.com/consul/tutorials/security/tls-encryption-secure)
    # across the cluster to verify authenticity of the Consul servers and clients.
    # Requires Consul v1.4.1+.
    tls:
      # If true, the Helm chart will enable TLS for Consul
      # servers and clients and all consul-k8s-control-plane components, as well as generate certificate
      # authority (optional) and server and client certificates.
      # This setting is required for [Cluster Peering](https://developer.hashicorp.com/consul/docs/connect/cluster-peering/k8s).
      enabled: false
  
      # Override global log verbosity level. One of "trace", "debug", "info", "warn", or "error".
      # @type: string
      logLevel: ""
  
      # If true, turns on the auto-encrypt feature on clients and servers.
      # It also switches consul-k8s-control-plane components to retrieve the CA from the servers
      # via the API. Requires Consul 1.7.1+.
      enableAutoEncrypt: false
  
      # A list of additional DNS names to set as Subject Alternative Names (SANs)
      # in the server certificate. This is useful when you need to access the
      # Consul server(s) externally, for example, if you're using the UI.
      # @type: array<string>
      serverAdditionalDNSSANs: []
  
      # A list of additional IP addresses to set as Subject Alternative Names (SANs)
      # in the server certificate. This is useful when you need to access the
      # Consul server(s) externally, for example, if you're using the UI.
      # @type: array<string>
      serverAdditionalIPSANs: []
  
      # If true, `verify_outgoing`, `verify_server_hostname`,
      # and `verify_incoming` for internal RPC communication will be set to `true` for Consul servers and clients.
      # Set this to false to incrementally roll out TLS on an existing Consul cluster.
      # Please refer to [TLS on existing clusters](https://developer.hashicorp.com/consul/docs/k8s/operations/tls-on-existing-cluster)
      # for more details.
      verify: true
  
      # If true, the Helm chart will configure Consul to disable the HTTP port on
      # both clients and servers and to only accept HTTPS connections.
      httpsOnly: true
  
      # A secret containing the certificate of the CA to use for TLS communication within the Consul cluster.
      # If you have generated the CA yourself with the consul CLI, you could use the following command to create the secret
      # in Kubernetes:
      #
      # ```shell-session
      # $ kubectl create secret generic consul-ca-cert \
      #     --from-file='tls.crt=./consul-agent-ca.pem'
      # ```
      # If you are using Vault as a secrets backend with TLS, `caCert.secretName` must be provided and should reference
      # the CA path for your PKI secrets engine. This should be of the form `pki/cert/ca` where `pki` is the mount point of your PKI secrets engine.
      # A read policy must be created and associated with the CA cert path for `global.tls.caCert.secretName`.
      # This will be consumed by the `global.secretsBackend.vault.consulCARole` role by all Consul components.
      # When using Vault the secretKey is not used.
      caCert:
        # The name of the Kubernetes or Vault secret that holds the CA certificate.
        # @type: string
        secretName: null
        # The key within the Kubernetes or Vault secret that holds the CA certificate.
        # @type: string
        secretKey: null
  
      # A Kubernetes or Vault secret containing the private key of the CA to use for
      # TLS communication within the Consul cluster. If you have generated the CA yourself
      # with the consul CLI, you could use the following command to create the secret
      # in Kubernetes:
      #
      # ```shell-session
      # $ kubectl create secret generic consul-ca-key \
      #     --from-file='tls.key=./consul-agent-ca-key.pem'
      # ```
      #
      # Note that we need the CA key so that we can generate server and client certificates.
      # It is particularly important for the client certificates since they need to have host IPs
      # as Subject Alternative Names. If you are setting server certs yourself via `server.serverCert`
      # and you are not enabling clients (or clients are enabled with autoEncrypt) then you do not
      # need to provide the CA key.
      caKey:
        # The name of the Kubernetes or Vault secret that holds the CA key.
        # @type: string
        secretName: null
        # The key within the Kubernetes or Vault secret that holds the CA key.
        # @type: string
        secretKey: null
  
      # This value defines additional annotations for
      # tls init jobs. This should be formatted as a multi-line string.
      #
      # ```yaml
      # annotations: |
      #   "sample/annotation1": "foo"
      #   "sample/annotation2": "bar"
      # ```
      #
      # @type: string
      annotations: null
  
    # [Enterprise Only] `enableConsulNamespaces` indicates that you are running
    # Consul Enterprise v1.7+ with a valid Consul Enterprise license and would
    # like to make use of configuration beyond registering everything into
    # the `default` Consul namespace. Additional configuration
    # options are found in the `consulNamespaces` section of both the catalog sync
    # and connect injector.
    enableConsulNamespaces: false
  
    # Configure ACLs.
    acls:
      # If true, the Helm chart will automatically manage ACL tokens and policies
      # for all Consul and consul-k8s-control-plane components.
      # This requires Consul >= 1.4.
      manageSystemACLs: false
  
      # Override global log verbosity level. One of "trace", "debug", "info", "warn", or "error".
      # @type: string
      logLevel: ""
  
      # A Kubernetes or Vault secret containing the bootstrap token to use for creating policies and
      # tokens for all Consul and consul-k8s-control-plane components. If `secretName` and `secretKey`
      # are unset, a default secret name and secret key are used. If the secret is populated, then
      # we will skip ACL bootstrapping of the servers and will only initialize ACLs for the Consul
      # clients and consul-k8s-control-plane system components.
      # If the secret is empty, then we will bootstrap ACLs on the Consul servers, and write the
      # bootstrap token to this secret. If ACLs are already bootstrapped on the servers, then the
      # secret must contain the bootstrap token.
      bootstrapToken:
        # The name of the Kubernetes or Vault secret that holds the bootstrap token.
        # If unset, this defaults to `{{ global.name }}-bootstrap-acl-token`.
        secretName: null
        # The key within the Kubernetes or Vault secret that holds the bootstrap token.
        # If unset, this defaults to `token`.
        secretKey: null
  
      # If true, an ACL token will be created that can be used in secondary
      # datacenters for replication. This should only be set to true in the
      # primary datacenter since the replication token must be created from that
      # datacenter.
      # In secondary datacenters, the secret needs to be imported from the primary
      # datacenter and referenced via `global.acls.replicationToken`.
      createReplicationToken: false
  
      # replicationToken references a secret containing the replication ACL token.
      # This token will be used by secondary datacenters to perform ACL replication
      # and create ACL tokens and policies.
      # This value is ignored if `bootstrapToken` is also set.
      replicationToken:
        # The name of the Kubernetes or Vault secret that holds the replication token.
        # @type: string
        secretName: null
        # The key within the Kubernetes or Vault secret that holds the replication token.
        # @type: string
        secretKey: null
  
      # The resource requests (CPU, memory, etc.) for the server-acl-init and server-acl-init-cleanup pods.
      # This should be a YAML map corresponding to a Kubernetes
      # [`ResourceRequirements``](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#resourcerequirements-v1-core)
      # object.
      #
      # Example:
      #
      # ```yaml
      # resources:
      #   requests:
      #     memory: '200Mi'
      #     cpu: '100m'
      #   limits:
      #     memory: '200Mi'
      #     cpu: '100m'
      # ```
      #
      # @recurse: false
      # @type: map
      resources:
        requests:
          memory: "50Mi"
          cpu: "50m"
        limits:
          memory: "50Mi"
          cpu: "50m"
  
      # partitionToken references a Vault secret containing the ACL token to be used in non-default partitions.
      # This value should only be provided in the default partition and only when setting
      # the `global.secretsBackend.vault.enabled` value to true.
      # Consul will use the value of the secret stored in Vault to create an ACL token in Consul with the value of the
      # secret as the secretID for the token.
      # In non-default, partitions set this secret as the `bootstrapToken`.
      partitionToken:
        # The name of the Vault secret that holds the partition token.
        # @type: string
        secretName: null
        # The key within the Vault secret that holds the parition token.
        # @type: string
        secretKey: null
  
      # tolerations configures the taints and tolerations for the server-acl-init
      # and server-acl-init-cleanup jobs. This should be a multi-line string matching the
      # [Tolerations](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/) array in a Pod spec.
      tolerations: ""
  
      # This value defines [`nodeSelector`](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector)
      # labels for the server-acl-init and server-acl-init-cleanup jobs pod assignment, formatted as a multi-line string.
      #
      # Example:
      #
      # ```yaml
      # nodeSelector: |
      #   beta.kubernetes.io/arch: amd64
      # ```
      #
      # @type: string
      nodeSelector: null
  
      # This value defines additional annotations for
      # acl init jobs. This should be formatted as a multi-line string.
      #
      # ```yaml
      # annotations: |
      #   "sample/annotation1": "foo"
      #   "sample/annotation2": "bar"
      # ```
      #
      # @type: string
      annotations: null
  
    # If argocd.enabled is set to true, following annotations are added to
    # job - server-acl-init-job
    # annotations -
    #   argocd.argoproj.io/hook: Sync
    #   argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd:
      enabled: true
  
    federation:
      enabled: false
  
    # Configures metrics for Consul service mesh
    metrics:
      enabled: true
  
      # Configures consul agent metrics. Only applicable if
      # `global.metrics.enabled` is true.
      # @type: boolean
      enableAgentMetrics: false
  
      # Configures consul agent underlying host metrics. Default is false.
      # Only applicable if `global.metrics.enabled` and `global.metrics.enableAgentMetrics` is true.
      # @type: boolean
      enableHostMetrics: false
  
      enableGatewayMetrics: false
  
      enableTelemetryCollector: false
  
      # Configures the list of filter rules to apply for allowing or blocking
      # metrics by prefix in the following format:
      #
      # A leading "+" will enable any metrics with the given prefix, and a leading "-" will block them.
      # If there is overlap between two rules, the more specific rule will take precedence.
      # Blocking will take priority if the same prefix is listed multiple times.
      prefixFilter:
        # @type: array<string>
        allowList: []
        # @type: array<string>
        blockList: []
  
        # Configures Kubernetes Prometheus/OpenMetrics auto-discovery annotations for use with Datadog.
        # This configuration is less common and more for advanced usage with custom metrics monitoring
        # configurations. Refer to the [Datadog documentation](https://docs.datadoghq.com/containers/kubernetes/prometheus/?tab=kubernetesadv2) for more details.
        openMetricsPrometheus:
          # @default: false
          # @type: boolean
          enabled: false
  
        otlp:
          # Enables forwarding of Consul's Telemetry Collector OTLP metrics for
          # ingestion by Datadog Agent.
          # @default: false
          # @type: boolean
          enabled: false
          # Protocol used for DataDog Endpoint OTLP ingestion.
          #
          # Valid protocol options are one of either:
          #
          #   - "http": will forward to DataDog HTTP OTLP Node Agent Endpoint default - "0.0.0.0:4318"
          #   - "grpc": will forward to DataDog gRPC OTLP Node Agent Endpoint default - "0.0.0.0:4317"
          #
          # @default: "http"
          # @type: string
          protocol: "http"
  
    openshift:
      enabled: false
  
    cloud:
      enabled: false
  
    #
    # Example:
    #
    # ```yaml
    # trustedCAs: [
    #   |
    #   -----BEGIN CERTIFICATE-----
    #   MIIC7jCCApSgAwIBAgIRAIq2zQEVexqxvtxP6J0bXAwwCgYIKoZIzj0EAwIwgbkx
    #   ...
    # ]
    # ```
    # @type: array<string>
    trustedCAs: []
  
  # Server, when enabled, configures a server cluster to run. This should
  # be disabled if you plan on connecting to a Consul cluster external to
  # the Kube cluster.
  server:
    enabled: true
  
    replicas: 1
  
    # A secret containing a certificate & key for the server agents to use
    # for TLS communication within the Consul cluster. Cert needs to be provided with
    # additional DNS name SANs so that it will work within the Kubernetes cluster:
    #
    # Kubernetes Secrets backend:
    # ```bash
    # consul tls cert create -server -days=730 -domain=consul -ca=consul-agent-ca.pem \
    #     -key=consul-agent-ca-key.pem -dc={{datacenter}} \
    #     -additional-dnsname="{{fullname}}-server" \
    #     -additional-dnsname="*.{{fullname}}-server" \
    #     -additional-dnsname="*.{{fullname}}-server.{{namespace}}" \
    #     -additional-dnsname="*.{{fullname}}-server.{{namespace}}.svc" \
    #     -additional-dnsname="*.server.{{datacenter}}.{{domain}}" \
    #     -additional-dnsname="server.{{datacenter}}.{{domain}}"
    # ```
    #
    # If you have generated the server-cert yourself with the consul CLI, you could use the following command
    # to create the secret in Kubernetes:
    #
    # ```bash
    # kubectl create secret generic consul-server-cert \
    #     --from-file='tls.crt=./dc1-server-consul-0.pem'
    #     --from-file='tls.key=./dc1-server-consul-0-key.pem'
    # ```
    #
    # Vault Secrets backend:
    # If you are using Vault as a secrets backend, a Vault Policy must be created which allows `["create", "update"]`
    # capabilities on the PKI issuing endpoint, which is usually of the form `pki/issue/consul-server`.
    # Complete [this tutorial](https://developer.hashicorp.com/consul/tutorials/vault-secure/vault-pki-consul-secure-tls)
    # to learn how to generate a compatible certificate.
    # Note: when using TLS, both the `server.serverCert` and `global.tls.caCert` which points to the CA endpoint of this PKI engine
    # must be provided.
    serverCert:
      # The name of the Vault secret that holds the PEM encoded server certificate.
      # @type: string
      secretName: null
  
    # Exposes the servers' gossip and RPC ports as hostPorts. To enable a client
    # agent outside of the k8s cluster to join the datacenter, you would need to
    # enable `server.exposeGossipAndRPCPorts`, `client.exposeGossipPorts`, and
    # set `server.ports.serflan.port` to a port not being used on the host. Since
    # `client.exposeGossipPorts` uses the hostPort 8301,
    # `server.ports.serflan.port` must be set to something other than 8301.
    exposeGossipAndRPCPorts: false
  
    # Configures ports for the consul servers.
    ports:
      # Configures the LAN gossip port for the consul servers. If you choose to
      # enable `server.exposeGossipAndRPCPorts` and `client.exposeGossipPorts`,
      # that will configure the LAN gossip ports on the servers and clients to be
      # hostPorts, so if you are running clients and servers on the same node the
      # ports will conflict if they are both 8301. When you enable
      # `server.exposeGossipAndRPCPorts` and `client.exposeGossipPorts`, you must
      # change this from the default to an unused port on the host, e.g. 9301. By
      # default the LAN gossip port is 8301 and configured as a containerPort on
      # the consul server Pods.
      serflan:
        port: 8301
  
    # This defines the disk size for configuring the
    storage: 10Gi
    storageClass: nfs-client
  
    resources:
      requests:
        memory: "200Mi"
        cpu: "100m"
      limits:
        memory: "200Mi"
        cpu: "100m"
  
  externalServers:
    enabled: false
  
  client:
    # If true, the chart will install all
    # the resources necessary for a Consul client on every Kubernetes node. This _does not_ require
    # `server.enabled`, since the agents can be configured to join an external cluster.
    # @type: boolean
    enabled: false
  
  dns:
    # @type: boolean
    enabled: false
  
  ui:
    enabled: true
  
    metrics:
      enabled: true
      provider: "prometheus"
  
      # baseURL is the URL of the prometheus server, usually the service URL.
      # This value is only used if `ui.enabled` is set to true.
      # @type: string
      baseURL: http://kube-prometheus-stack-prometheus.monitoring.svc.cluster.local:9090/
  
    dashboardURLTemplates:
      # Sets [`dashboardURLTemplates.service`](https://developer.hashicorp.com/consul/docs/agent/config/config-files#ui_config_dashboard_url_templates_service).
      service: ""
  
  syncCatalog:
    enabled: false
  
  connectInject:
    enabled: true
  
    replicas: 1
  
    cni:
      enabled: false
  
    metrics:
      defaultEnabled: "-"
  
  meshGateway:
    enabled: false
  
  ingressGateways:
    enabled: false
  
  webhookCertManager:
    tolerations: null
  
  # Configures a demo Prometheus installation.
  prometheus:
    enabled: false
  
  tests:
    enabled: false
  
  telemetryCollector:
    enabled: false
